{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dist/angular-meteor-auth.min.js","webpack:///webpack/bootstrap 959a99d1f8bc7258291f","webpack:///./src/angular-meteor-auth.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Object","defineProperty","value","name","angular","$Mixer","$log","$$Auth","vm","arguments","length","undefined","autorun","currentUser","Accounts","user","currentUserId","userId","isLoggingIn","loggingIn","Package","Error","errors","required","forbidden","$awaitUser","validate","_this","$bindToContext","caller","_","isFunction","deferred","$$defer","computation","getReactively","stop","$$afterFlush","reject","isValid","resolve","error","isString","promise","bind","fn","_fn","_len","args","Array","_key","Tracker","afterFlush","apply","concat","$waitForUser","err","debug","$requireUser","$requireValidUser","service","$rootScope","_this2","keys","forEach","k","stripped","substr","run","mixin"],"mappings":"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","file":"dist/angular-meteor-auth.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angularMeteorAuth\"] = factory();\n\telse\n\t\troot[\"angularMeteorAuth\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","/*! angular-meteor-auth v1.0.2 */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angularMeteorAuth\"] = factory();\n\telse\n\t\troot[\"angularMeteorAuth\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar name = 'angular-meteor.auth';\n\texports.default = name;\n\t\n\t\n\tangular.module(name, ['angular-meteor.mixer', 'angular-meteor.core', 'angular-meteor.view-model', 'angular-meteor.reactive'])\n\t\n\t/*\n\t  A mixin which provides us with authentication related methods and properties.\n\t  This mixin comes in a seperate package called `angular-meteor-auth`. Note that `accounts-base`\n\t  package needs to be installed in order for this module to work, otherwise an error will be thrown.\n\t */\n\t.factory('$$Auth', ['$Mixer', '$log', function ($Mixer, $log) {\n\t  var Accounts = (Package['accounts-base'] || {}).Accounts;\n\t\n\t  if (!Accounts) {\n\t    throw Error('`angular-meteor.auth` module requires `accounts-base` package, ' + 'please run `meteor add accounts-base` before use');\n\t  }\n\t\n\t  var errors = {\n\t    required: 'AUTH_REQUIRED',\n\t    forbidden: 'FORBIDDEN'\n\t  };\n\t\n\t  function $$Auth() {\n\t    var vm = arguments.length <= 0 || arguments[0] === undefined ? this : arguments[0];\n\t\n\t    // reset auth properties\n\t    this.autorun(function () {\n\t      vm.currentUser = Accounts.user();\n\t      vm.currentUserId = Accounts.userId();\n\t      vm.isLoggingIn = Accounts.loggingIn();\n\t    });\n\t  }\n\t\n\t  // Waits for user to finish the login process. Gets an optional validation function which\n\t  // will validate if the current user is valid or not. Returns a promise which will be rejected\n\t  // once login has failed or user is not valid, otherwise it will be resolved with the current\n\t  // user\n\t  $$Auth.$awaitUser = function (validate) {\n\t    var _this = this;\n\t\n\t    validate = validate ? this.$bindToContext($Mixer.caller, validate) : function () {\n\t      return true;\n\t    };\n\t\n\t    if (!_.isFunction(validate)) {\n\t      throw Error('argument 1 must be a function');\n\t    }\n\t\n\t    var deferred = this.$$defer();\n\t\n\t    // Note the promise is being fulfilled in the next event loop to avoid\n\t    // nested computations, otherwise the outer computation will cancel the\n\t    // inner one once the scope has been destroyed which will lead to subscription\n\t    // failures. Happens mainly after resolving a route.\n\t    var computation = this.autorun(function (computation) {\n\t      if (_this.getReactively('isLoggingIn')) return;\n\t      // Stop computation once a user has logged in\n\t      computation.stop();\n\t\n\t      if (!_this.currentUser) return _this.$$afterFlush(deferred.reject, errors.required);\n\t\n\t      var isValid = validate(_this.currentUser);\n\t      // Resolve the promise if validation has passed\n\t      if (isValid === true) return _this.$$afterFlush(deferred.resolve, _this.currentUser);\n\t\n\t      var error = void 0;\n\t\n\t      if (_.isString(isValid) || isValid instanceof Error) {\n\t        error = isValid;\n\t      } else {\n\t        error = errors.forbidden;\n\t      }\n\t\n\t      return _this.$$afterFlush(deferred.reject, error);\n\t    });\n\t\n\t    var promise = deferred.promise;\n\t    promise.stop = computation.stop.bind(computation);\n\t    return promise;\n\t  };\n\t\n\t  // Calls a function with the provided args after flush\n\t  $$Auth.$$afterFlush = function (fn) {\n\t    var _fn;\n\t\n\t    if (_.isString(fn)) {\n\t      fn = this[fn];\n\t    }\n\t\n\t    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      args[_key - 1] = arguments[_key];\n\t    }\n\t\n\t    return Tracker.afterFlush((_fn = fn).bind.apply(_fn, [this].concat(args)));\n\t  };\n\t\n\t  // API v0.2.0\n\t  // Aliases with small modificatons\n\t\n\t  // No validation\n\t  // Silent error\n\t  $$Auth.$waitForUser = function () {\n\t    // Silent error\n\t    return this.$awaitUser().catch(function (err) {\n\t      $log.debug('$awaitUser', err);\n\t    });\n\t  };\n\t\n\t  // No validation\n\t  $$Auth.$requireUser = function () {\n\t    return this.$awaitUser();\n\t  };\n\t\n\t  // Full functionality\n\t  $$Auth.$requireValidUser = function () {\n\t    return this.$awaitUser.apply(this, arguments);\n\t  };\n\t\n\t  return $$Auth;\n\t}])\n\t\n\t/*\n\t  External service for syntactic sugare.\n\t  Originally created as UI-router's resolve handler.\n\t */\n\t.service('$auth', ['$rootScope', '$$Auth', function ($rootScope, $$Auth) {\n\t  var _this2 = this;\n\t\n\t  // Note that services are initialized once we call them which means that the mixin\n\t  // will be available by then\n\t  _.keys($$Auth).forEach(function (k) {\n\t    var stripped = k.substr(1);\n\t    // Not using bind() so it would be testable\n\t    _this2[stripped] = function () {\n\t      return $rootScope[k].apply($rootScope, arguments);\n\t    };\n\t  });\n\t}]).run(['$Mixer', '$$Auth', function ($Mixer, $$Auth) {\n\t  $Mixer.mixin($$Auth);\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** dist/angular-meteor-auth.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 959a99d1f8bc7258291f\n **/","const name = 'angular-meteor.auth';\nexport default name;\n\nangular.module(name, [\n  'angular-meteor.mixer',\n  'angular-meteor.core',\n  'angular-meteor.view-model',\n  'angular-meteor.reactive'\n])\n\n/*\n  A mixin which provides us with authentication related methods and properties.\n  This mixin comes in a seperate package called `angular-meteor-auth`. Note that `accounts-base`\n  package needs to be installed in order for this module to work, otherwise an error will be thrown.\n */\n.factory('$$Auth', [\n  '$Mixer', '$log',\n\nfunction($Mixer, $log) {\n  const Accounts = (Package['accounts-base'] || {}).Accounts;\n\n  if (!Accounts) {\n    throw Error(\n      '`angular-meteor.auth` module requires `accounts-base` package, ' +\n      'please run `meteor add accounts-base` before use'\n    );\n  }\n\n  const errors = {\n    required: 'AUTH_REQUIRED',\n    forbidden: 'FORBIDDEN'\n  };\n\n  function $$Auth(vm = this) {\n    // reset auth properties\n    this.autorun(() => {\n      vm.currentUser = Accounts.user();\n      vm.currentUserId = Accounts.userId();\n      vm.isLoggingIn = Accounts.loggingIn();\n    });\n  }\n\n  // Waits for user to finish the login process. Gets an optional validation function which\n  // will validate if the current user is valid or not. Returns a promise which will be rejected\n  // once login has failed or user is not valid, otherwise it will be resolved with the current\n  // user\n  $$Auth.$awaitUser = function(validate) {\n    validate = validate ? this.$bindToContext($Mixer.caller, validate) : () => true;\n\n    if (!_.isFunction(validate)) {\n      throw Error('argument 1 must be a function');\n    }\n\n    const deferred = this.$$defer();\n\n    // Note the promise is being fulfilled in the next event loop to avoid\n    // nested computations, otherwise the outer computation will cancel the\n    // inner one once the scope has been destroyed which will lead to subscription\n    // failures. Happens mainly after resolving a route.\n    const computation = this.autorun((computation) => {\n      if (this.getReactively('isLoggingIn')) return;\n      // Stop computation once a user has logged in\n      computation.stop();\n\n      if (!this.currentUser) return this.$$afterFlush(deferred.reject, errors.required);\n\n      const isValid = validate(this.currentUser);\n      // Resolve the promise if validation has passed\n      if (isValid === true) return this.$$afterFlush(deferred.resolve, this.currentUser);\n\n      let error;\n\n      if (_.isString(isValid) || isValid instanceof Error) {\n        error = isValid;\n      }\n      else {\n        error = errors.forbidden;\n      }\n\n      return this.$$afterFlush(deferred.reject, error);\n    });\n\n    const promise = deferred.promise;\n    promise.stop = computation.stop.bind(computation);\n    return promise;\n  };\n\n  // Calls a function with the provided args after flush\n  $$Auth.$$afterFlush = function(fn, ...args) {\n    if (_.isString(fn)) {\n      fn = this[fn];\n    }\n\n    return Tracker.afterFlush(fn.bind(this, ...args));\n  };\n\n  // API v0.2.0\n  // Aliases with small modificatons\n\n  // No validation\n  // Silent error\n  $$Auth.$waitForUser = function() {\n    // Silent error\n    return this.$awaitUser().catch(err => {\n        $log.debug('$awaitUser', err);\n    });\n  };\n\n  // No validation\n  $$Auth.$requireUser = function() {\n    return this.$awaitUser();\n  };\n\n  // Full functionality\n  $$Auth.$requireValidUser = function(...args) {\n    return this.$awaitUser(...args);\n  };\n\n  return $$Auth;\n}])\n\n/*\n  External service for syntactic sugare.\n  Originally created as UI-router's resolve handler.\n */\n.service('$auth', [\n  '$rootScope',\n  '$$Auth',\n\nfunction($rootScope, $$Auth) {\n  // Note that services are initialized once we call them which means that the mixin\n  // will be available by then\n  _.keys($$Auth).forEach((k) => {\n    const stripped = k.substr(1);\n    // Not using bind() so it would be testable\n    this[stripped] = (...args) => $rootScope[k](...args);\n  });\n}])\n\n.run([\n  '$Mixer',\n  '$$Auth',\n\nfunction($Mixer, $$Auth) {\n  $Mixer.mixin($$Auth);\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/angular-meteor-auth.js\n **/"],"sourceRoot":""}